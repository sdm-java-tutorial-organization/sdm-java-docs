package deprecated.connect;

/**
 * #NIO가뭐에요? (java.nio)
 * IO와 다르게
 * [채널]방식으로 입출력을 처리하고,
 * [버퍼]를 사용하고,
 * [비동기] 방식을 지원하고,
 * [블로킹과 넌블로킹]을 모두 지원합니다.
 * <p>
 * #IO와NIO의차이점이뭐에요?
 * 데이터를 입출력한다는 목적은 동일하나, 방식에있어서 크게 차이가 납니다.
 * - 입출력방식 :: 스트림 vs 채널
 * - 버퍼방식 :: 넌버퍼 vs 버퍼
 * - 비동기방식 :: 지원안함 vs 지원
 * - 블로킹/넌블로킹 :: 블로킹지원 vs 모두지원
 * <p>
 * #스트림과채널이뭐가 달라요?
 * [IO]는 스트림기반입니다.
 * 스트림은 입력스트림과 출력스트림으로 구분되는데 데이터를 읽기 위해는 입력스트림을 생성해야하고, 데이터를 쓰기위해서는 출력스트림을 생성해야합니다.
 * [NIO]는 채널에 기반합니다.
 * 채널은 스트림과 달리 양방향으로 입력과 출력이 가능합니다. 그래서 입력과 출력을 위한 별도의 채널을 만들 필요가 없습니다.
 * <p>
 * #버퍼와넌버퍼의차이가 뭐에요?
 * [IO]는 1바이트를 쓰면 입력스트림이 1바이트를 읽습니다. 이런 시스템은 대체로 느립니다.
 * 버퍼(메모리저장소)를 사용해서 복수개의 바이트를 한꺼번에 입력받고 출력하는 것이 빠른 성능을 냅니다.
 * 그래서 IO는 버퍼를 제공해주는 보조스트림 (BufferedInputStream/BufferedOutputStream)을 사용하기도 합니다.
 * [NIO]는 기본적으로 버퍼를 사용해서 입출력을 하기 때문에 IO보다는 입출력 성능이 좋습니다.
 * <p>
 * #블로킹vs넌블로킹
 * [IO]는 블로킹이가능합니다. 스트림의 read()나 write() 메소드를 호출하면 테이터가 입력되기 전까지 스레드는 블로킹상태가됩니다.
 * IO스레드가 블로킹되면 다른일을 할 수 없고, 블로킹을 빠저나오기 위해 인터럽트도 할 수 없습니다.
 * 블로킹을 빠져나올 수 있는 유일한 방법은 스트림을 닫는 것입니다.
 * => 읽고 쓰는 작업을 지시한 후에는 그 작업이 끝나야 return 되는 bloking 방식
 * <p>
 * #블로킹과 인터럽트
 * [IO]의 Socket에서는 입출력스트림의 read() write() 메소드로 작업스레드가 블로킹됩니다.
 * 다른 스레드가 작업 스레드의 interrupt() 메소드를 호출해도 블로킹상태가 풀리지 않습니다.
 * Socket의 close() 메소드를 호출해서 SocketException을 발생시켜야함
 * <p>
 * [NIO]의 SocketChannel의 경우 read()와 write() 메소드를 호출하면 ClosedByInterruptException이 발생
 * SocketChannel이 즉시 닫히면서 블로킹 상태가 풀립니다. 물론 close()도 가능 ( AsynchronousException 발생 )
 * <p>
 * #넌블로킹
 * 넌블로킹은 입출력 작업시 스레드가 블로킹되지 않는 것을 말합니다.
 * NIO의 넌블로킹은 입출력 작업 준비가 완료된 채널만 선택해서 작업 스레드가 처리하기 때문에 작업 스레드가 블로킹되지 않습니다.
 * <p>
 * #셀렉터 (Selector)
 * <p>
 * <p>
 * #인터럽트???
 * 스레드를 종료시키는 요청
 * <p>
 * #그럼무엇을써야하나요?
 * 네트워크 프로그램을 개발할때 IO와 NIO 선택기준에 대해 생각해봅시다.
 * <p>
 * [NIO]는 연결 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 경우에 사용하는 것이 좋습니다.
 * 블특정 다수의 클라이언트 연결 또는 멀티 파일들을 넌블로킹이나 비동기로 처리할 수 있기 때문에 과도한 스레드 생성을 피하고,
 * 스레드를 효과적으로 재사용한다는 점에서 큰 장점이 있습니다.
 * 또한 운영체제의 버퍼(다이렉트 버퍼)를 이용한 입출력이 가능해 입출력 성능이 향상됩니다.
 * <p>
 * [IO]는 연결 클라이언트수가 적고, 대용량 데이터를 처리면서 순차적으로 처리될 필요성이 있을때 더 유리합니다.
 * NIO는 버퍼의 할당 크기도 문제가 되고, 스레드에서 입출력 처리가 오래 걸리면 대기하는 작업의 수가 늘어나기 때문에
 * 제한된 스레드로 처리하는 것이 오히려 불리할 수 있습니다.
 * 모든 입출력 작업에 버퍼를 무조건 사용해야 하므로 받은 즉시 처리하는 IO 보다는 조금 복잡합니다.
 * <p>
 * #자료
 * - https://homoefficio.github.io/2016/08/06/Java-NIO%EB%8A%94-%EC%83%9D%EA%B0%81%EB%A7%8C%ED%81%BC-non-blocking-%ED%95%98%EC%A7%80-%EC%95%8A%EB%8B%A4/
 * - http://joochang.tistory.com/78
 */

public class Doc_NIO {
    public static void main(String[] args) throws Exception {

        // ================================================================================================================

        /**
         * # [Path & Paths]
         *
         * Doc_Path.java 참조
         */

        // ================================================================================================================

        /**
         * # [FileSystems]
         *
         * Doc_FileSystem.java 참조
         */

        // ================================================================================================================


        /**
         * # [Files]
         *
         * Doc_Files.java 참조
         */

        // ================================================================================================================

        /**
         * #와치서비스(WatchService)
         *  디렉토리내부에서파일생성, 삭제, 수정등의 내용반화를 감시하는데 사용됩니다.
         *  파일변경통지 메커니즘으로 알려져 있습니다.
         *
         * => Doc_WatchService.java 참조
         * */

        // ================================================================================================================

        /**
         * #버퍼
         *
         * => Doc_Buffer.java 참조
         */

        // ================================================================================================================

        /**
         * #파일채널
         *
         * => Doc_FileChannel.java 참조
         */

        // ================================================================================================================

        /**
         * #블로킹과 인터럽트
         *  [IO]의 Socket에서는 입출력스트림의 read() write() 메소드로 작업스레드가 블로킹됩니다.
         *  다른 스레드가 작업 스레드의 interrupt() 메소드를 호출해도 블로킹상태가 풀리지 않습니다.
         *  Socket의 close() 메소드를 호출해서 SocketException을 발생시켜야함
         *
         *  [NIO]의 SocketChannel의 경우 read()와 write() 메소드를 호출하면 ClosedByInterruptException이 발생
         *  SocketChannel이 즉시 닫히면서 블로킹 상태가 풀립니다. 물론 close()도 가능 ( AsynchronousException 발생 )
         *
         * */

        Thread thread = null;


    }

    Thread thread;

    public void receive() {
        thread = new Thread() {
            @Override
            public void run() {
                try {

                    /**
                     * 01. 다른스레드가 interrupt를 호출
                     * 02. CloasedByInterruptException 발생 ()
                     * */
                    // int byteCount = socketChannel.read(byteBuffer);

                } catch (Exception e) {
                    // CloasedByInterruptException 발생
                    // socketChannel.close();
                }
            }
        };
        thread.start();
    }

    public void stop() {
        thread.interrupt();
    }


}
